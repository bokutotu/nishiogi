## 1. システム全体の流れ

1. **ユーザー問い合わせ受付・解析**  
   - ユーザーからの問い合わせを受け、必要な情報（例：特定機能の実装箇所、内部構造、依存関係など）を解析します。  
   - 問い合わせの内容により、どのタスクを実行するかの優先順位を決定します。

2. **マスターエージェントによる全体プランニングとタスクディスパッチ**  
   - コードベース全体のディレクトリ構造、過去の解析結果、既存のメタ情報を元に解析の戦略を策定。  
   - 以下のタスクに細分化し、非同期実行できるようスレイブエージェントへ割り当てます：  
     - ディレクトリ構造の把握（`tree`）  
     - キーワード検索（`grep`）  
     - コードシグニチャ検索（`signature_search`）  
     - 静的解析（依存関係、内部構造、コード品質指標の抽出）  
     - ファイルフィルタリング（`find`）  
   - それぞれのタスクに対し、エラー発生時は自動リトライおよび詳細なエラーログを生成し、フィードバックループを構築します。

3. **スレイブエージェントによるタスク実行**  
   - 割り当てられたタスクに応じ、下記のコマンドを実行します：  
     - `tree`: コードベースの全体ディレクトリ構造を把握  
     - `grep`: 指定キーワード（例：「targetFunction」）を含むコード行を検索  
     - `signature_search`: 関数・クラス定義の抽出とその周辺情報の確認  
     - `static_analysis`: 静的解析ツールを用いて依存関係、内部構造、コード品質を解析  
     - `find`: ファイル名フィルタリング（例：Controller関連ファイル）  
   - 各タスクは非同期で実行され、結果を整形してマスターエージェントへ送信。  
   - **エラー対策:**  
     - 自動リトライ機構による再実行  
     - エラーログの詳細な記録と報告  
   - **結果が長大な場合:**  
     - ランタイムで出力結果をストリーム処理し、必要に応じて要約・断片化して報告  
     - LLMから実行コマンドに対しては、過剰な出力が予想される場合は、実行前に「出力量の制限」または「部分的に返す」指示を付与

4. **結果の統合とフィードバックループ**  
   - スレイブエージェントからの各タスク結果をマスターエージェントが受領し、統一フォーマットに正規化。  
   - 統合結果を元に不足情報の検出や、再実行が必要なタスクへのフィードバックを即座に行います。  
   - エラー発生やリトライ状況を考慮しながら、最終的な解析結果の信頼性を確保します。

5. **最終報告の生成とユーザーへの回答**  
   - 全タスクの結果および静的解析の詳細情報から、特定機能の実装箇所、内部構造、依存関係などをユーザーに分かりやすい形式で報告します。  
   - 必要に応じて、結果が長大な場合は要約情報と詳細ログへのリンクや参照を提供することで、ユーザーの理解を補助します。

---

## 2. エージェント間の関係

- **マスターエージェント**  
  - **役割:** ユーザー問い合わせの解析、タスク全体のプランニング、タスクディスパッチ、進捗・エラー管理、結果の統合および最終報告の生成。  
  - **特徴:**  
    - タスクの依存関係を管理し、進捗状況とリトライ回数の監視を実施。  
    - 必要に応じて、LLMに対してランタイムコマンド実行の指示や、過大な結果の場合の出力制御（要約、分割処理など）を指示。

- **スレイブエージェント**  
  - **役割:** マスターエージェントからの指示に基づき、各タスク（`tree`, `grep`, `signature_search`, `static_analysis`, `find`）を非同期に実行。  
  - **特徴:**  
    - 各タスクの実行結果を整形し、エラー発生時の自動リトライ機能を実装。  
    - 静的解析ツールを活用して、コードの依存関係や内部構造の詳細を抽出。  
    - 実行結果が長大な場合は、結果の要約または断片化処理を適用し、マスターエージェントへ送信。

- **コミュニケーション**  
  - JSONスキーマに基づいた統一メッセージ形式で、タスク要求、結果報告、フィードバック、エラー情報、リトライ状況などを交換。  
  - 各メッセージには、送信者、受信者、タイムスタンプ、メッセージタイプ（task_request, task_result, feedback, status_update, error）、タスクID、コマンド、ペイロード、状態、メタデータが含まれます。

---

## 3. 開発者が作るべきコンポーネント

- **エージェント実行ツール／フレームワーク**  
  - 非同期処理とエージェント間のJSONベースのメッセージングシステムの実装。  
  - タスク進捗管理、エラー回復（リトライ、エラーログ集約）機能の統合。

- **マスターエージェント**  
  - ユーザー問い合わせ解析、タスクプランニング、タスクディスパッチ、結果統合、フィードバック生成の実装。  
  - エラー発生時のリトライ指示や、長大な実行結果に対する要約・分割処理の指示機能。

- **スレイブエージェント**  
  - 各種コマンド（`tree`, `grep`, `signature_search`, `static_analysis`, `find`）の実行、エラー時の自動リトライ、エラーログの生成・報告の実装。  
  - 実行結果の整形と正規化処理、特に静的解析ツールの出力のパースおよび要約処理。

- **コマンド実行モジュール**  
  - 各タスクの出力をパースし、統一フォーマットに変換するユーティリティ。  
  - 静的解析結果から依存関係やコード品質指標などを抽出・要約する機能。

- **ログおよび状態管理機能**  
  - 各エージェントの動作履歴、タスク進捗、エラー発生状況、リトライ回数を記録し、フィードバックループで利用。  
  - 過大な出力が発生した場合、ログの断片化や圧縮による対処も検討。

---

## 4. 提案されるプロンプト例

### マスターエージェント用プロンプト

```
【マスターエージェント: タスク管理・フィードバック】
あなたはマスターエージェントです。ユーザーの最終ゴールは「特定の機能の実装箇所を特定し、その実装の概要と内部構造、依存関係を把握する」ことです。

1. 初めに、コードベース全体のディレクトリ構造把握のため、スレイブエージェントに「tree」コマンドを実行させ、関連ディレクトリ候補を抽出してください。
2. 次に、特定キーワード（例：「targetFunction」）を含むコード行を「grep」で検索し、関連箇所を確認させてください。
3. 必要に応じ、コードシグニチャ検索で定義部分を調査し、静的解析ツールを用いて依存関係や内部構造、コード品質指標を解析させてください。
4. 各タスクの結果を受領し、不足情報があれば再実行や追加タスクの指示、エラー発生時のリトライ状況の確認をフィードバックしてください。

すべての結果が揃ったら、ユーザーに対して最終報告を分かりやすい形式で提示してください。
```

### スレイブエージェント用プロンプト例

#### A. ディレクトリ構造の把握タスク

```
【タスク: ディレクトリ構造の確認】
あなたはスレイブエージェントです。指定されたコードベースのディレクトリ構造を把握するため、以下のコマンドを実行してください。

コマンド: tree /path/to/codebase

出力結果から、関連しそうなディレクトリやファイル（例：特定機能に関係するモジュール）をリストアップし、報告してください。エラーが発生した場合は、詳細なエラーログとともに自動リトライしてください。
```

#### B. キーワード検索タスク

```
【タスク: キーワード検索】
あなたはスレイブエージェントです。指定キーワード「targetFunction」を含むコード行をコードベース全体から検索してください。

コマンド: grep -R "targetFunction" /path/to/codebase

検索結果を、ファイル名と該当箇所の抜粋と共に整理し、報告してください。エラー時には自動リトライを実施してください。
```

#### C. コードシグニチャ検索タスク

```
【タスク: コードシグニチャの検索】
あなたはスレイブエージェントです。特定のシグニチャ（例：「def targetFunction」または「class TargetClass」）をコードベースから検索し、定義部分および周辺情報を抽出してください。

コマンド: signature_search "def\s+targetFunction" /path/to/codebase

見つかったシグニチャ、該当ファイル、行番号などをリストアップし、簡潔に報告してください。エラー発生時は詳細ログを送信し、再試行してください。
```

#### D. 静的解析タスク

```
【タスク: 静的解析の実行】
あなたはスレイブエージェントです。静的解析ツールを用いて、コードベース全体の依存関係や内部構造、コード品質の指標を解析してください。

コマンド: static_analysis --path /path/to/codebase --target "targetFunction"

解析結果から、関数・クラスの相互依存、変数の使用状況、コード品質指標などを抽出し、報告してください。エラー時は再試行処理を実施し、詳細ログを含めて報告してください。
```

#### E. ファイルフィルタリングタスク

```
【タスク: ファイルフィルタリング】
あなたはスレイブエージェントです。ファイル名に「Controller」が含まれるファイルを、コードベースから抽出してください。

コマンド: find /path/to/codebase -name "*Controller*"

抽出されたファイルパス一覧を報告してください。エラー発生時は、再試行と詳細なエラーログの報告を行ってください。
```

---

## 5. エージェント間通信スキーマ（JSON例）

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Agent Communication Schema",
  "type": "object",
  "properties": {
    "sender": {
      "type": "string",
      "description": "メッセージ送信エージェントのID（例： 'master', 'slave_1'）"
    },
    "receiver": {
      "type": "string",
      "description": "メッセージ受信対象エージェントのID"
    },
    "timestamp": {
      "type": "string",
      "format": "date-time",
      "description": "メッセージ生成時刻（ISO 8601形式）"
    },
    "message_type": {
      "type": "string",
      "enum": ["task_request", "task_result", "feedback", "status_update", "error"],
      "description": "メッセージの種類（タスク要求、結果報告、フィードバック、状態更新、エラー報告など）"
    },
    "task_id": {
      "type": "string",
      "description": "関連タスクの一意識別子（該当する場合）"
    },
    "command": {
      "type": "string",
      "description": "実行すべきコマンド（例： 'tree', 'grep', 'signature_search', 'static_analysis', 'find'）"
    },
    "payload": {
      "type": "object",
      "description": "コマンド実行結果やタスク詳細情報（各タスクに応じたデータ）",
      "additionalProperties": true
    },
    "status": {
      "type": "string",
      "enum": ["pending", "in_progress", "completed", "failed"],
      "description": "タスクまたはメッセージの進捗状況"
    },
    "metadata": {
      "type": "object",
      "description": "追加情報（例：優先度、再試行回数など）",
      "properties": {
        "priority": {
          "type": "integer",
          "description": "タスクの優先度（数値が小さいほど高優先度）"
        },
        "retry_count": {
          "type": "integer",
          "description": "タスクの再試行回数"
        }
      },
      "additionalProperties": true
    }
  },
  "required": ["sender", "receiver", "timestamp", "message_type"]
}
```

**例：タスク要求メッセージ**

```json
{
  "sender": "master",
  "receiver": "slave_1",
  "timestamp": "2025-02-26T12:00:00Z",
  "message_type": "task_request",
  "task_id": "task-1234",
  "command": "grep",
  "payload": {
    "search_pattern": "targetFunction",
    "search_path": "/path/to/codebase"
  },
  "status": "pending",
  "metadata": {
    "priority": 1,
    "retry_count": 0
  }
}
```

**例：タスク結果メッセージ**

```json
{
  "sender": "slave_1",
  "receiver": "master",
  "timestamp": "2025-02-26T12:05:00Z",
  "message_type": "task_result",
  "task_id": "task-1234",
  "command": "grep",
  "payload": {
    "results": [
      {
        "file": "/path/to/codebase/module1.py",
        "line": 42,
        "snippet": "def targetFunction(param):"
      }
    ]
  },
  "status": "completed",
  "metadata": {
    "priority": 1
  }
}
```

---

## 6. 追加：LLMランタイムへの指示および結果の長大化への回避策

- **ランタイムコマンド実行依頼:**  
  - LLMが特定コマンドの実行を依頼する際、実行前に実行対象の出力が過大にならないかをチェックし、必要なら「出力量制限」や「部分的出力」「ストリーミング処理」の指示を付与します。  
  - 例：`grep`実行時に結果が数千行に及ぶ場合は、先頭数百行のみ返すか、概要の要約とエラー部分の詳細ログを別途生成する。

- **結果の断片化および要約:**  
  - 各スレイブエージェントは、出力があまりにも長大な場合、ランタイム側で自動的に要約処理を実施。  
  - 重要箇所のみを抜粋し、追加情報が必要な場合はマスターエージェントから再実行や詳細ログ取得の指示を出す。  
  - これにより、ユーザーにとっても読みやすい報告書を生成できると同時に、リソース消費を最適化します。

---

## まとめ

- **全体フロー:**  
  ユーザー問い合わせ解析 → マスターエージェントによるタスクプランニングと非同期タスクディスパッチ → スレイブエージェントによる各種コマンド実行（`tree`, `grep`, `signature_search`, `static_analysis`, `find`）およびエラー回復（自動リトライ、詳細ログ送信） → 統合結果の正規化とフィードバック → ユーザーへの最終報告

- **エージェント間連携:**  
  マスターエージェントが全体を統括し、タスク依存関係と進捗管理、エラー発生時のリトライ指示を実施。スレイブエージェントは各タスクの実行と、出力が過大になった場合の要約・断片化処理を担います。

- **開発者実装のポイント:**  
  - 非同期処理、エージェント間通信（JSONスキーマベース）の堅牢な実装  
  - エラー対策（自動リトライ、詳細エラーログ出力）と出力結果の柔軟な要約・断片化機能  
  - 各タスクの実行結果の正規化と統合処理による、ユーザーにとっての分かりやすい最終報告

